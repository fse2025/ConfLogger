====================TaintedSinkInfo:=======================
-------------TaintedSinkInfo----------
fileName:	MBeanRegistry.java	methodSinagture:	org.apache.zookeeper.jmx.MBeanRegistry.register(Lorg/apache/zookeeper/jmx/ZKMBeanInfo;Lorg/apache/zookeeper/jmx/ZKMBeanInfo;)V	methodLines:	92:113
blockLines:	95:-1
paras:	null
TaintedStat:	NORMAL register:conditional branch(eq, to iindex=31) 3,7 Node: < Application, Lorg/apache/zookeeper/jmx/MBeanRegistry, register(Lorg/apache/zookeeper/jmx/ZKMBeanInfo;Lorg/apache/zookeeper/jmx/ZKMBeanInfo;)V > Context: Everywhere
Source:	NORMAL_RET_CALLER:Node: < Application, Lorg/apache/zookeeper/server/quorum/QuorumPeer, run()V > Context: Everywhere[30]27 = invokevirtual < Application, Lorg/apache/zookeeper/server/quorum/QuorumPeer, getMyId()J > 1 @73 exception:26
Tainted Path:	NORMAL_RET_CALLER:Node: < Application, Lorg/apache/zookeeper/server/quorum/QuorumPeer, run()V > Context: Everywhere[30]27 = invokevirtual < Application, Lorg/apache/zookeeper/server/quorum/QuorumPeer, getMyId()J > 1 @73 exception:26
NORMAL run:29 = compare 27,28 opcode=cmp Node: < Application, Lorg/apache/zookeeper/server/quorum/QuorumPeer, run()V > Context: Everywhere
NORMAL run:conditional branch(ne, to iindex=59) 29,22 Node: < Application, Lorg/apache/zookeeper/server/quorum/QuorumPeer, run()V > Context: Everywhere
NORMAL run:34 = getfield < Application, Lorg/apache/zookeeper/server/quorum/QuorumPeer, jmxQuorumBean, <Application,Lorg/apache/zookeeper/server/quorum/QuorumBean> > 1 Node: < Application, Lorg/apache/zookeeper/server/quorum/QuorumPeer, run()V > Context: Everywhere
PARAM_CALLER:Node: < Application, Lorg/apache/zookeeper/server/quorum/QuorumPeer, run()V > Context: Everywhere[48]invokevirtual < Application, Lorg/apache/zookeeper/jmx/MBeanRegistry, register(Lorg/apache/zookeeper/jmx/ZKMBeanInfo;Lorg/apache/zookeeper/jmx/ZKMBeanInfo;)V > 33,30,34 @106 exception:35 v34
PARAM_CALLEE:Node: < Application, Lorg/apache/zookeeper/jmx/MBeanRegistry, register(Lorg/apache/zookeeper/jmx/ZKMBeanInfo;Lorg/apache/zookeeper/jmx/ZKMBeanInfo;)V > Context: Everywhere v3
NORMAL register:conditional branch(eq, to iindex=31) 3,7 Node: < Application, Lorg/apache/zookeeper/jmx/MBeanRegistry, register(Lorg/apache/zookeeper/jmx/ZKMBeanInfo;Lorg/apache/zookeeper/jmx/ZKMBeanInfo;)V > Context: Everywhere

-------------TaintedSinkInfo----------
fileName:	MBeanRegistry.java	methodSinagture:	org.apache.zookeeper.jmx.MBeanRegistry.register(Lorg/apache/zookeeper/jmx/ZKMBeanInfo;Lorg/apache/zookeeper/jmx/ZKMBeanInfo;)V	methodLines:	92:113
blockLines:	93:-1
paras:	readonlymode.enabled
TaintedStat:	NORMAL register:conditional branch(ne, to iindex=10) 2,7 Node: < Application, Lorg/apache/zookeeper/jmx/MBeanRegistry, register(Lorg/apache/zookeeper/jmx/ZKMBeanInfo;Lorg/apache/zookeeper/jmx/ZKMBeanInfo;)V > Context: Everywhere
Source:	NORMAL_RET_CALLER:Node: < Application, Lorg/apache/zookeeper/server/quorum/QuorumPeer, run()V > Context: Everywhere[121]84 = invokestatic < Application, Ljava/lang/Boolean, getBoolean(Ljava/lang/String;)Z > 82 @310 exception:83
Tainted Path:	NORMAL_RET_CALLER:Node: < Application, Lorg/apache/zookeeper/server/quorum/QuorumPeer, run()V > Context: Everywhere[121]84 = invokestatic < Application, Ljava/lang/Boolean, getBoolean(Ljava/lang/String;)Z > 82 @310 exception:83
NORMAL run:conditional branch(eq, to iindex=188) 84,22 Node: < Application, Lorg/apache/zookeeper/server/quorum/QuorumPeer, run()V > Context: Everywhere
NORMAL run:invokevirtual < Application, Ljava/lang/Thread, start()V > 92 @355 exception:94 Node: < Application, Lorg/apache/zookeeper/server/quorum/QuorumPeer, run()V > Context: Everywhere
METHOD_ENTRY:Node: synthetic < Primordial, Ljava/lang/Thread, start()V > Context: Everywhere
NORMAL start:invokeinterface < Primordial, Ljava/lang/Runnable, run()V > 4 @5 exception:5 Node: synthetic < Primordial, Ljava/lang/Thread, start()V > Context: Everywhere
METHOD_ENTRY:Node: < Application, Lorg/apache/zookeeper/server/quorum/QuorumPeer, run()V > Context: Everywhere
NORMAL run:11 = getfield < Application, Lorg/apache/zookeeper/server/quorum/QuorumPeer, jmxQuorumBean, <Application,Lorg/apache/zookeeper/server/quorum/QuorumBean> > 1 Node: < Application, Lorg/apache/zookeeper/server/quorum/QuorumPeer, run()V > Context: Everywhere
PARAM_CALLER:Node: < Application, Lorg/apache/zookeeper/server/quorum/QuorumPeer, run()V > Context: Everywhere[15]invokevirtual < Application, Lorg/apache/zookeeper/jmx/MBeanRegistry, register(Lorg/apache/zookeeper/jmx/ZKMBeanInfo;Lorg/apache/zookeeper/jmx/ZKMBeanInfo;)V > 10,11,12 @35 exception:13 v11
PARAM_CALLEE:Node: < Application, Lorg/apache/zookeeper/jmx/MBeanRegistry, register(Lorg/apache/zookeeper/jmx/ZKMBeanInfo;Lorg/apache/zookeeper/jmx/ZKMBeanInfo;)V > Context: Everywhere v2
NORMAL register:conditional branch(ne, to iindex=10) 2,7 Node: < Application, Lorg/apache/zookeeper/jmx/MBeanRegistry, register(Lorg/apache/zookeeper/jmx/ZKMBeanInfo;Lorg/apache/zookeeper/jmx/ZKMBeanInfo;)V > Context: Everywhere



====================ExtendedBlocks:=======================


====================MethodSrc:=======================
    public void register(ZKMBeanInfo bean, ZKMBeanInfo parent) throws JMException {
        assert bean != null;
        String path = null;
        if (parent != null) {
            path = mapBean2Path.get(parent);
            assert path != null;
        }
        path = makeFullPath(path, parent);
        if (bean.isHidden()) {
            return;
        }
        ObjectName oname = makeObjectName(path, bean);
        try {
            synchronized (LOCK) {
                mBeanServer.registerMBean(bean, oname);
                mapBean2Path.put(bean, path);
            }
        } catch (JMException e) {
            LOG.warn("Failed to register MBean {}", bean.getName());
            throw e;
        }
    }



====================ctx:=======================
CtxCodeBlock{node=Node: < Application, Lorg/apache/zookeeper/server/ServerCnxnFactory, registerConnection(Lorg/apache/zookeeper/server/ServerCnxn;)V > Context: Everywhere, blocks=[BB[SSA:16..16]9 - org.apache.zookeeper.server.ServerCnxnFactory.registerConnection(Lorg/apache/zookeeper/server/ServerCnxn;)V, BB[SSA:15..15]8 - org.apache.zookeeper.server.ServerCnxnFactory.registerConnection(Lorg/apache/zookeeper/server/ServerCnxn;)V, BB[SSA:17..18]10 - org.apache.zookeeper.server.ServerCnxnFactory.registerConnection(Lorg/apache/zookeeper/server/ServerCnxn;)V, BB[SSA:-1..-2]15 - org.apache.zookeeper.server.ServerCnxnFactory.registerConnection(Lorg/apache/zookeeper/server/ServerCnxn;)V], numberOfBasicBlocks=4, firstLineNumber=217, lastLineNumber=218, firstMethodNumber=213, lastMethodNumber=224, isFirstLineValid=true, methodSrcCode=
    public void registerConnection(ServerCnxn serverCnxn) {
        if (zkServer != null) {
            ConnectionBean jmxConnectionBean = new ConnectionBean(serverCnxn, zkServer);
            try {
                MBeanRegistry.getInstance().register(jmxConnectionBean, zkServer.jmxServerBean);
                connectionBeans.put(serverCnxn, jmxConnectionBean);
            } catch (JMException e) {
                LOG.warn("Could not register connection", e);
            }
        }

    }

}
CtxCodeBlock{node=Node: < Application, Lorg/apache/zookeeper/server/quorum/LeaderZooKeeperServer, registerJMX(Lorg/apache/zookeeper/server/quorum/LearnerHandlerBean;)Z > Context: Everywhere, blocks=[BB[SSA:4..4]3 - org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/quorum/LearnerHandlerBean;)Z, BB[SSA:1..3]2 - org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/quorum/LearnerHandlerBean;)Z, BB[SSA:5..6]4 - org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/quorum/LearnerHandlerBean;)Z, BB[SSA:-1..-2]7 - org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/quorum/LearnerHandlerBean;)Z], numberOfBasicBlocks=4, firstLineNumber=250, lastLineNumber=251, firstMethodNumber=249, lastMethodNumber=255, isFirstLineValid=true, methodSrcCode=
        try {
            MBeanRegistry.getInstance().register(handlerBean, jmxServerBean);
            return true;
        } catch (JMException e) {
            LOG.warn("Could not register connection", e);
        }
        return false;
    }
}
CtxCodeBlock{node=Node: < Application, Lorg/apache/zookeeper/server/quorum/LearnerZooKeeperServer, registerJMX(Lorg/apache/zookeeper/server/ZooKeeperServerBean;Lorg/apache/zookeeper/server/quorum/LocalPeerBean;)V > Context: Everywhere, blocks=[BB[SSA:24..26]14 - org.apache.zookeeper.server.quorum.LearnerZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/ZooKeeperServerBean;Lorg/apache/zookeeper/server/quorum/LocalPeerBean;)V, BB[SSA:23..23]13 - org.apache.zookeeper.server.quorum.LearnerZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/ZooKeeperServerBean;Lorg/apache/zookeeper/server/quorum/LocalPeerBean;)V, BB[SSA:27..27]15 - org.apache.zookeeper.server.quorum.LearnerZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/ZooKeeperServerBean;Lorg/apache/zookeeper/server/quorum/LocalPeerBean;)V, BB[SSA:-1..-2]19 - org.apache.zookeeper.server.quorum.LearnerZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/ZooKeeperServerBean;Lorg/apache/zookeeper/server/quorum/LocalPeerBean;)V], numberOfBasicBlocks=4, firstLineNumber=122, lastLineNumber=126, firstMethodNumber=110, lastMethodNumber=127, isFirstLineValid=true, methodSrcCode=
        // register with JMX
        if (self.jmxLeaderElectionBean != null) {
            try {
                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);
            } catch (Exception e) {
                LOG.warn("Failed to register with JMX", e);
            }
            self.jmxLeaderElectionBean = null;
        }

        try {
            jmxServerBean = serverBean;
            MBeanRegistry.getInstance().register(serverBean, localPeerBean);
        } catch (Exception e) {
            LOG.warn("Failed to register with JMX", e);
            jmxServerBean = null;
        }
    }

}
CtxCodeBlock{node=Node: < Application, Lorg/apache/zookeeper/server/quorum/QuorumPeer, run()V > Context: Everywhere, blocks=[BB[SSA:14..15]8 - org.apache.zookeeper.server.quorum.QuorumPeer.run()V, BB[SSA:12..13]7 - org.apache.zookeeper.server.quorum.QuorumPeer.run()V, BB[SSA:16..17]9 - org.apache.zookeeper.server.quorum.QuorumPeer.run()V, BB[SSA:-1..-2]228 - org.apache.zookeeper.server.quorum.QuorumPeer.run()V, BB[SSA:48..48]25 - org.apache.zookeeper.server.quorum.QuorumPeer.run()V, BB[SSA:45..47]24 - org.apache.zookeeper.server.quorum.QuorumPeer.run()V, BB[SSA:49..49]26 - org.apache.zookeeper.server.quorum.QuorumPeer.run()V, BB[SSA:-1..-2]228 - org.apache.zookeeper.server.quorum.QuorumPeer.run()V, BB[SSA:69..69]34 - org.apache.zookeeper.server.quorum.QuorumPeer.run()V, BB[SSA:66..68]33 - org.apache.zookeeper.server.quorum.QuorumPeer.run()V, BB[SSA:70..71]35 - org.apache.zookeeper.server.quorum.QuorumPeer.run()V, BB[SSA:-1..-2]228 - org.apache.zookeeper.server.quorum.QuorumPeer.run()V], numberOfBasicBlocks=12, firstLineNumber=1448, lastLineNumber=1449, firstMethodNumber=1428, lastMethodNumber=1597, isFirstLineValid=true, methodSrcCode=
    public void run() {
        updateThreadName();

        LOG.debug("Starting quorum peer");
        try {
            jmxQuorumBean = new QuorumBean(this);
            MBeanRegistry.getInstance().register(jmxQuorumBean, null);
            for (QuorumServer s : getView().values()) {
                ZKMBeanInfo p;
                if (getMyId() == s.id) {
                    p = jmxLocalPeerBean = new LocalPeerBean(this);
                    try {
                        MBeanRegistry.getInstance().register(p, jmxQuorumBean);
                    } catch (Exception e) {
                        LOG.warn("Failed to register with JMX", e);
                        jmxLocalPeerBean = null;
                    }
                } else {
                    RemotePeerBean rBean = new RemotePeerBean(this, s);
                    try {
                        MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);
                        jmxRemotePeerBean.put(s.id, rBean);
                    } catch (Exception e) {
                        LOG.warn("Failed to register with JMX", e);
                    }
                }
            }
        } catch (Exception e) {
            LOG.warn("Failed to register with JMX", e);
            jmxQuorumBean = null;
        }

        try {
            /*
             * Main loop
             */
            while (running) {
                if (unavailableStartTime == 0) {
                    unavailableStartTime = Time.currentElapsedTime();
                }

                switch (getPeerState()) {
                case LOOKING:
                    LOG.info("LOOKING");
                    ServerMetrics.getMetrics().LOOKING_COUNT.add(1);

                    if (Boolean.getBoolean("readonlymode.enabled")) {
                        LOG.info("Attempting to start ReadOnlyZooKeeperServer");

                        // Create read-only server but don't start it immediately
                        final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);

                        // Instead of starting roZk immediately, wait some grace
                        // period before we decide we're partitioned.
                        //
                        // Thread is used here because otherwise it would require
                        // changes in each of election strategy classes which is
                        // unnecessary code coupling.
                        Thread roZkMgr = new Thread() {
                            public void run() {
                                try {
                                    // lower-bound grace period to 2 secs
                                    sleep(Math.max(2000, tickTime));
                                    if (ServerState.LOOKING.equals(getPeerState())) {
                                        roZk.startup();
                                    }
                                } catch (InterruptedException e) {
                                    LOG.info("Interrupted while attempting to start ReadOnlyZooKeeperServer, not started");
                                } catch (Exception e) {
                                    LOG.error("FAILED to start ReadOnlyZooKeeperServer", e);
                                }
                            }
                        };
                        try {
                            roZkMgr.start();
                            reconfigFlagClear();
                            if (shuttingDownLE) {
                                shuttingDownLE = false;
                                startLeaderElection();
                            }
                            setCurrentVote(makeLEStrategy().lookForLeader());
                            checkSuspended();
                        } catch (Exception e) {
                            LOG.warn("Unexpected exception", e);
                            setPeerState(ServerState.LOOKING);
                        } finally {
                            // If the thread is in the the grace period, interrupt
                            // to come out of waiting.
                            roZkMgr.interrupt();
                            roZk.shutdown();
                        }
                    } else {
                        try {
                            reconfigFlagClear();
                            if (shuttingDownLE) {
                                shuttingDownLE = false;
                                startLeaderElection();
                            }
                            setCurrentVote(makeLEStrategy().lookForLeader());
                        } catch (Exception e) {
                            LOG.warn("Unexpected exception", e);
                            setPeerState(ServerState.LOOKING);
                        }
                    }
                    break;
                case OBSERVING:
                    try {
                        LOG.info("OBSERVING");
                        setObserver(makeObserver(logFactory));
                        observer.observeLeader();
                    } catch (Exception e) {
                        LOG.warn("Unexpected exception", e);
                    } finally {
                        observer.shutdown();
                        setObserver(null);
                        updateServerState();

                        // Add delay jitter before we switch to LOOKING
                        // state to reduce the load of ObserverMaster
                        if (isRunning()) {
                            Observer.waitForObserverElectionDelay();
                        }
                    }
                    break;
                case FOLLOWING:
                    try {
                        LOG.info("FOLLOWING");
                        setFollower(makeFollower(logFactory));
                        follower.followLeader();
                    } catch (Exception e) {
                        LOG.warn("Unexpected exception", e);
                    } finally {
                        follower.shutdown();
                        setFollower(null);
                        updateServerState();
                    }
                    break;
                case LEADING:
                    LOG.info("LEADING");
                    try {
                        setLeader(makeLeader(logFactory));
                        leader.lead();
                        setLeader(null);
                    } catch (Exception e) {
                        LOG.warn("Unexpected exception", e);
                    } finally {
                        if (leader != null) {
                            leader.shutdown("Forcing shutdown");
                            setLeader(null);
                        }
                        updateServerState();
                    }
                    break;
                }
            }
        } finally {
            LOG.warn("QuorumPeer main thread exited");
            MBeanRegistry instance = MBeanRegistry.getInstance();
            instance.unregister(jmxQuorumBean);
            instance.unregister(jmxLocalPeerBean);

            for (RemotePeerBean remotePeerBean : jmxRemotePeerBean.values()) {
                instance.unregister(remotePeerBean);
            }

            jmxQuorumBean = null;
            jmxLocalPeerBean = null;
            jmxRemotePeerBean = null;
        }
    }

}
CtxCodeBlock{node=Node: < Application, Lorg/apache/zookeeper/server/quorum/ReadOnlyZooKeeperServer, registerJMX()V > Context: Everywhere, blocks=[BB[SSA:13..13]9 - org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer.registerJMX()V, BB[SSA:11..12]8 - org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer.registerJMX()V, BB[SSA:14..14]10 - org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer.registerJMX()V, BB[SSA:-1..-2]14 - org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer.registerJMX()V], numberOfBasicBlocks=4, firstLineNumber=135, lastLineNumber=139, firstMethodNumber=133, lastMethodNumber=140, isFirstLineValid=true, methodSrcCode=
        try {
            jmxDataTreeBean = new DataTreeBean(getZKDatabase().getDataTree());
            MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);
        } catch (Exception e) {
            LOG.warn("Failed to register with JMX", e);
            jmxDataTreeBean = null;
        }
    }

}
CtxCodeBlock{node=Node: < Application, Lorg/apache/zookeeper/server/quorum/LeaderZooKeeperServer, registerJMX()V > Context: Everywhere, blocks=[BB[SSA:13..13]9 - org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.registerJMX()V, BB[SSA:11..12]8 - org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.registerJMX()V, BB[SSA:14..14]10 - org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.registerJMX()V, BB[SSA:-1..-2]14 - org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.registerJMX()V], numberOfBasicBlocks=4, firstLineNumber=221, lastLineNumber=225, firstMethodNumber=219, lastMethodNumber=226, isFirstLineValid=true, methodSrcCode=
        try {
            jmxDataTreeBean = new DataTreeBean(getZKDatabase().getDataTree());
            MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);
        } catch (Exception e) {
            LOG.warn("Failed to register with JMX", e);
            jmxDataTreeBean = null;
        }
    }

}
CtxCodeBlock{node=Node: < Application, Lorg/apache/zookeeper/server/quorum/QuorumPeer, updateRemotePeerMXBeans(Ljava/util/Map;)V > Context: Everywhere, blocks=[BB[SSA:80..80]41 - org.apache.zookeeper.server.quorum.QuorumPeer.updateRemotePeerMXBeans(Ljava/util/Map;)V, BB[SSA:77..79]40 - org.apache.zookeeper.server.quorum.QuorumPeer.updateRemotePeerMXBeans(Ljava/util/Map;)V, BB[SSA:81..82]42 - org.apache.zookeeper.server.quorum.QuorumPeer.updateRemotePeerMXBeans(Ljava/util/Map;)V, BB[SSA:-1..-2]70 - org.apache.zookeeper.server.quorum.QuorumPeer.updateRemotePeerMXBeans(Ljava/util/Map;)V], numberOfBasicBlocks=4, firstLineNumber=2340, lastLineNumber=2341, firstMethodNumber=2325, lastMethodNumber=2357, isFirstLineValid=true, methodSrcCode=
    private void updateRemotePeerMXBeans(Map<Long, QuorumServer> newMembers) {
        Set<Long> existingMembers = new HashSet<>(newMembers.keySet());
        existingMembers.retainAll(jmxRemotePeerBean.keySet());
        for (Long id : existingMembers) {
            RemotePeerBean rBean = jmxRemotePeerBean.get(id);
            rBean.setQuorumServer(newMembers.get(id));
        }

        Set<Long> joiningMembers = new HashSet<>(newMembers.keySet());
        joiningMembers.removeAll(jmxRemotePeerBean.keySet());
        joiningMembers.remove(getMyId()); // remove self as it is local bean
        for (Long id : joiningMembers) {
            QuorumServer qs = newMembers.get(id);
            RemotePeerBean rBean = new RemotePeerBean(this, qs);
            try {
                MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);
                jmxRemotePeerBean.put(qs.id, rBean);
            } catch (Exception e) {
                LOG.warn("Failed to register with JMX", e);
            }
        }

        Set<Long> leavingMembers = new HashSet<>(jmxRemotePeerBean.keySet());
        leavingMembers.removeAll(newMembers.keySet());
        for (Long id : leavingMembers) {
            RemotePeerBean rBean = jmxRemotePeerBean.remove(id);
            try {
                MBeanRegistry.getInstance().unregister(rBean);
            } catch (Exception e) {
                LOG.warn("Failed to unregister with JMX", e);
            }
        }
    }

}
CtxCodeBlock{node=Node: < Application, Lorg/apache/zookeeper/server/quorum/ReadOnlyZooKeeperServer, registerJMX(Lorg/apache/zookeeper/server/ZooKeeperServerBean;Lorg/apache/zookeeper/server/quorum/LocalPeerBean;)V > Context: Everywhere, blocks=[BB[SSA:4..6]3 - org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/ZooKeeperServerBean;Lorg/apache/zookeeper/server/quorum/LocalPeerBean;)V, BB[SSA:3..3]2 - org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/ZooKeeperServerBean;Lorg/apache/zookeeper/server/quorum/LocalPeerBean;)V, BB[SSA:7..7]4 - org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/ZooKeeperServerBean;Lorg/apache/zookeeper/server/quorum/LocalPeerBean;)V, BB[SSA:-1..-2]8 - org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/ZooKeeperServerBean;Lorg/apache/zookeeper/server/quorum/LocalPeerBean;)V], numberOfBasicBlocks=4, firstLineNumber=146, lastLineNumber=150, firstMethodNumber=144, lastMethodNumber=151, isFirstLineValid=true, methodSrcCode=
        try {
            jmxServerBean = serverBean;
            MBeanRegistry.getInstance().register(serverBean, localPeerBean);
        } catch (Exception e) {
            LOG.warn("Failed to register with JMX", e);
            jmxServerBean = null;
        }
    }

}
CtxCodeBlock{node=Node: < Application, Lorg/apache/zookeeper/server/quorum/FollowerZooKeeperServer, registerJMX(Lorg/apache/zookeeper/server/quorum/LearnerHandlerBean;)Z > Context: Everywhere, blocks=[BB[SSA:4..4]3 - org.apache.zookeeper.server.quorum.FollowerZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/quorum/LearnerHandlerBean;)Z, BB[SSA:1..3]2 - org.apache.zookeeper.server.quorum.FollowerZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/quorum/LearnerHandlerBean;)Z, BB[SSA:5..6]4 - org.apache.zookeeper.server.quorum.FollowerZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/quorum/LearnerHandlerBean;)Z, BB[SSA:-1..-2]7 - org.apache.zookeeper.server.quorum.FollowerZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/quorum/LearnerHandlerBean;)Z], numberOfBasicBlocks=4, firstLineNumber=166, lastLineNumber=167, firstMethodNumber=165, lastMethodNumber=171, isFirstLineValid=true, methodSrcCode=
        try {
            MBeanRegistry.getInstance().register(handlerBean, jmxServerBean);
            return true;
        } catch (JMException e) {
            LOG.warn("Could not register connection", e);
        }
        return false;
    }
}
CtxCodeBlock{node=Node: < Application, Lorg/apache/zookeeper/server/quorum/LearnerZooKeeperServer, registerJMX()V > Context: Everywhere, blocks=[BB[SSA:13..13]9 - org.apache.zookeeper.server.quorum.LearnerZooKeeperServer.registerJMX()V, BB[SSA:11..12]8 - org.apache.zookeeper.server.quorum.LearnerZooKeeperServer.registerJMX()V, BB[SSA:14..14]10 - org.apache.zookeeper.server.quorum.LearnerZooKeeperServer.registerJMX()V, BB[SSA:-1..-2]14 - org.apache.zookeeper.server.quorum.LearnerZooKeeperServer.registerJMX()V], numberOfBasicBlocks=4, firstLineNumber=102, lastLineNumber=106, firstMethodNumber=100, lastMethodNumber=107, isFirstLineValid=true, methodSrcCode=
        try {
            jmxDataTreeBean = new DataTreeBean(getZKDatabase().getDataTree());
            MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);
        } catch (Exception e) {
            LOG.warn("Failed to register with JMX", e);
            jmxDataTreeBean = null;
        }
    }

}
CtxCodeBlock{node=Node: < Application, Lorg/apache/zookeeper/server/quorum/FastLeaderElection, lookForLeader()Lorg/apache/zookeeper/server/quorum/Vote; > Context: Everywhere, blocks=[BB[SSA:13..13]10 - org.apache.zookeeper.server.quorum.FastLeaderElection.lookForLeader()Lorg/apache/zookeeper/server/quorum/Vote;, BB[SSA:12..12]9 - org.apache.zookeeper.server.quorum.FastLeaderElection.lookForLeader()Lorg/apache/zookeeper/server/quorum/Vote;, BB[SSA:14..14]11 - org.apache.zookeeper.server.quorum.FastLeaderElection.lookForLeader()Lorg/apache/zookeeper/server/quorum/Vote;, BB[SSA:-1..-2]339 - org.apache.zookeeper.server.quorum.FastLeaderElection.lookForLeader()Lorg/apache/zookeeper/server/quorum/Vote;], numberOfBasicBlocks=4, firstLineNumber=916, lastLineNumber=920, firstMethodNumber=914, lastMethodNumber=1143, isFirstLineValid=true, methodSrcCode=
        try {
            self.jmxLeaderElectionBean = new LeaderElectionBean();
            MBeanRegistry.getInstance().register(self.jmxLeaderElectionBean, self.jmxLocalPeerBean);
        } catch (Exception e) {
            LOG.warn("Failed to register with JMX", e);
            self.jmxLeaderElectionBean = null;
        }

        self.start_fle = Time.currentElapsedTime();
        try {
            /*
             * The votes from the current leader election are stored in recvset. In other words, a vote v is in recvset
             * if v.electionEpoch == logicalclock. The current participant uses recvset to deduce on whether a majority
             * of participants has voted for it.
             */
            Map<Long, Vote> recvset = new HashMap<>();

            /*
             * The votes from previous leader elections, as well as the votes from the current leader election are
             * stored in outofelection. Note that notifications in a LOOKING state are not stored in outofelection.
             * Only FOLLOWING or LEADING notifications are stored in outofelection. The current participant could use
             * outofelection to learn which participant is the leader if it arrives late (i.e., higher logicalclock than
             * the electionEpoch of the received notifications) in a leader election.
             */
            Map<Long, Vote> outofelection = new HashMap<>();

            int notTimeout = minNotificationInterval;

            synchronized (this) {
                logicalclock.incrementAndGet();
                updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());
            }

            LOG.info(
                "New election. My id = {}, proposed zxid=0x{}",
                self.getMyId(),
                Long.toHexString(proposedZxid));
            sendNotifications();

            SyncedLearnerTracker voteSet = null;

            /*
             * Loop in which we exchange notifications until we find a leader
             */

            while ((self.getPeerState() == ServerState.LOOKING) && (!stop)) {
                /*
                 * Remove next notification from queue, times out after 2 times
                 * the termination time
                 */
                Notification n = recvqueue.poll(notTimeout, TimeUnit.MILLISECONDS);

                /*
                 * Sends more notifications if haven't received enough.
                 * Otherwise processes new notification.
                 */
                if (n == null) {
                    if (manager.haveDelivered()) {
                        sendNotifications();
                    } else {
                        manager.connectAll();
                    }

                    /*
                     * Exponential backoff
                     */
                    notTimeout = Math.min(notTimeout << 1, maxNotificationInterval);

                    /*
                     * When a leader failure happens on a master, the backup will be supposed to receive the honour from
                     * Oracle and become a leader, but the honour is likely to be delay. We do a re-check once timeout happens
                     *
                     * The leader election algorithm does not provide the ability of electing a leader from a single instance
                     * which is in a configuration of 2 instances.
                     * */
                    if (self.getQuorumVerifier() instanceof QuorumOracleMaj
                            && self.getQuorumVerifier().revalidateVoteset(voteSet, notTimeout != minNotificationInterval)) {
                        setPeerState(proposedLeader, voteSet);
                        Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);
                        leaveInstance(endVote);
                        return endVote;
                    }

                    LOG.info("Notification time out: {} ms", notTimeout);

                } else if (validVoter(n.sid) && validVoter(n.leader)) {
                    /*
                     * Only proceed if the vote comes from a replica in the current or next
                     * voting view for a replica in the current or next voting view.
                     */
                    switch (n.state) {
                    case LOOKING:
                        if (getInitLastLoggedZxid() == -1) {
                            LOG.debug("Ignoring notification as our zxid is -1");
                            break;
                        }
                        if (n.zxid == -1) {
                            LOG.debug("Ignoring notification from member with -1 zxid {}", n.sid);
                            break;
                        }
                        // If notification > current, replace and send messages out
                        if (n.electionEpoch > logicalclock.get()) {
                            logicalclock.set(n.electionEpoch);
                            recvset.clear();
                            if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) {
                                updateProposal(n.leader, n.zxid, n.peerEpoch);
                            } else {
                                updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());
                            }
                            sendNotifications();
                        } else if (n.electionEpoch < logicalclock.get()) {
                                LOG.debug(
                                    "Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x{}, logicalclock=0x{}",
                                    Long.toHexString(n.electionEpoch),
                                    Long.toHexString(logicalclock.get()));
                            break;
                        } else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {
                            updateProposal(n.leader, n.zxid, n.peerEpoch);
                            sendNotifications();
                        }

                        LOG.debug(
                            "Adding vote: from={}, proposed leader={}, proposed zxid=0x{}, proposed election epoch=0x{}",
                            n.sid,
                            n.leader,
                            Long.toHexString(n.zxid),
                            Long.toHexString(n.electionEpoch));

                        // don't care about the version if it's in LOOKING state
                        recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));

                        voteSet = getVoteTracker(recvset, new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch));

                        if (voteSet.hasAllQuorums()) {

                            // Verify if there is any change in the proposed leader
                            while ((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != null) {
                                if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {
                                    recvqueue.put(n);
                                    break;
                                }
                            }

                            /*
                             * This predicate is true once we don't read any new
                             * relevant message from the reception queue
                             */
                            if (n == null) {
                                setPeerState(proposedLeader, voteSet);
                                Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);
                                leaveInstance(endVote);
                                return endVote;
                            }
                        }
                        break;
                    case OBSERVING:
                        LOG.debug("Notification from observer: {}", n.sid);
                        break;

                        /*
                        * In ZOOKEEPER-3922, we separate the behaviors of FOLLOWING and LEADING.
                        * To avoid the duplication of codes, we create a method called followingBehavior which was used to
                        * shared by FOLLOWING and LEADING. This method returns a Vote. When the returned Vote is null, it follows
                        * the original idea to break swtich statement; otherwise, a valid returned Vote indicates, a leader
                        * is generated.
                        *
                        * The reason why we need to separate these behaviors is to make the algorithm runnable for 2-node
                        * setting. An extra condition for generating leader is needed. Due to the majority rule, only when
                        * there is a majority in the voteset, a leader will be generated. However, in a configuration of 2 nodes,
                        * the number to achieve the majority remains 2, which means a recovered node cannot generate a leader which is
                        * the existed leader. Therefore, we need the Oracle to kick in this situation. In a two-node configuration, the Oracle
                        * only grants the permission to maintain the progress to one node. The oracle either grants the permission to the
                        * remained node and makes it a new leader when there is a faulty machine, which is the case to maintain the progress.
                        * Otherwise, the oracle does not grant the permission to the remained node, which further causes a service down.
                        *
                        * In the former case, when a failed server recovers and participate in the leader election, it would not locate a
                        * new leader because there does not exist a majority in the voteset. It fails on the containAllQuorum() infinitely due to
                        * two facts. First one is the fact that it does do not have a majority in the voteset. The other fact is the fact that
                        * the oracle would not give the permission since the oracle already gave the permission to the existed leader, the healthy machine.
                        * Logically, when the oracle replies with negative, it implies the existed leader which is LEADING notification comes from is a valid leader.
                        * To threat this negative replies as a permission to generate the leader is the purpose to separate these two behaviors.
                        *
                        *
                        * */
                    case FOLLOWING:
                        /*
                        * To avoid duplicate codes
                        * */
                        Vote resultFN = receivedFollowingNotification(recvset, outofelection, voteSet, n);
                        if (resultFN == null) {
                            break;
                        } else {
                            return resultFN;
                        }
                    case LEADING:
                        /*
                        * In leadingBehavior(), it performs followingBehvior() first. When followingBehavior() returns
                        * a null pointer, ask Oracle whether to follow this leader.
                        * */
                        Vote resultLN = receivedLeadingNotification(recvset, outofelection, voteSet, n);
                        if (resultLN == null) {
                            break;
                        } else {
                            return resultLN;
                        }
                    default:
                        LOG.warn("Notification state unrecognized: {} (n.state), {}(n.sid)", n.state, n.sid);
                        break;
                    }
                } else {
                    if (!validVoter(n.leader)) {
                        LOG.warn("Ignoring notification for non-cluster member sid {} from sid {}", n.leader, n.sid);
                    }
                    if (!validVoter(n.sid)) {
                        LOG.warn("Ignoring notification for sid {} from non-quorum member sid {}", n.leader, n.sid);
                    }
                }
            }
            return null;
        } finally {
            try {
                if (self.jmxLeaderElectionBean != null) {
                    MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);
                }
            } catch (Exception e) {
                LOG.warn("Failed to unregister with JMX", e);
            }
            self.jmxLeaderElectionBean = null;
            LOG.debug("Number of connection processing threads: {}", manager.getConnectionThreadCount());
        }
    }
}
CtxCodeBlock{node=Node: < Application, Lorg/apache/zookeeper/server/ZooKeeperServer, registerJMX()V > Context: Everywhere, blocks=[BB[SSA:9..10]6 - org.apache.zookeeper.server.ZooKeeperServer.registerJMX()V, BB[SSA:7..8]5 - org.apache.zookeeper.server.ZooKeeperServer.registerJMX()V, BB[SSA:11..12]7 - org.apache.zookeeper.server.ZooKeeperServer.registerJMX()V, BB[SSA:-1..-2]23 - org.apache.zookeeper.server.ZooKeeperServer.registerJMX()V, BB[SSA:24..24]15 - org.apache.zookeeper.server.ZooKeeperServer.registerJMX()V, BB[SSA:22..23]14 - org.apache.zookeeper.server.ZooKeeperServer.registerJMX()V, BB[SSA:25..25]16 - org.apache.zookeeper.server.ZooKeeperServer.registerJMX()V, BB[SSA:-1..-2]23 - org.apache.zookeeper.server.ZooKeeperServer.registerJMX()V], numberOfBasicBlocks=8, firstLineNumber=774, lastLineNumber=778, firstMethodNumber=768, lastMethodNumber=783, isFirstLineValid=true, methodSrcCode=
        try {
            jmxServerBean = new ZooKeeperServerBean(this);
            MBeanRegistry.getInstance().register(jmxServerBean, null);

            try {
                jmxDataTreeBean = new DataTreeBean(zkDb.getDataTree());
                MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);
            } catch (Exception e) {
                LOG.warn("Failed to register with JMX", e);
                jmxDataTreeBean = null;
            }
        } catch (Exception e) {
            LOG.warn("Failed to register with JMX", e);
            jmxServerBean = null;
        }
    }

}
CtxCodeBlock{node=Node: < Application, Lorg/apache/zookeeper/server/quorum/LeaderZooKeeperServer, registerJMX(Lorg/apache/zookeeper/server/quorum/LeaderBean;Lorg/apache/zookeeper/server/quorum/LocalPeerBean;)V > Context: Everywhere, blocks=[BB[SSA:24..26]14 - org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/quorum/LeaderBean;Lorg/apache/zookeeper/server/quorum/LocalPeerBean;)V, BB[SSA:23..23]13 - org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/quorum/LeaderBean;Lorg/apache/zookeeper/server/quorum/LocalPeerBean;)V, BB[SSA:27..27]15 - org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/quorum/LeaderBean;Lorg/apache/zookeeper/server/quorum/LocalPeerBean;)V, BB[SSA:-1..-2]19 - org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.registerJMX(Lorg/apache/zookeeper/server/quorum/LeaderBean;Lorg/apache/zookeeper/server/quorum/LocalPeerBean;)V], numberOfBasicBlocks=4, firstLineNumber=241, lastLineNumber=245, firstMethodNumber=229, lastMethodNumber=246, isFirstLineValid=true, methodSrcCode=
        // register with JMX
        if (self.jmxLeaderElectionBean != null) {
            try {
                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);
            } catch (Exception e) {
                LOG.warn("Failed to register with JMX", e);
            }
            self.jmxLeaderElectionBean = null;
        }

        try {
            jmxServerBean = leaderBean;
            MBeanRegistry.getInstance().register(leaderBean, localPeerBean);
        } catch (Exception e) {
            LOG.warn("Failed to register with JMX", e);
            jmxServerBean = null;
        }
    }

}
